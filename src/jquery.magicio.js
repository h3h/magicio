// Generated by CoffeeScript 1.6.2
/*!
* Magicio 0.1
*
* Copyright 2013, Brad Fults - http://bradfults.com/
* Released under the MIT License
* https://github.com/h3h/magicio/LICENSE
*
* Thanks to Dave Rupert for inspiration from Lettering.js
* https://github.com/davatron5000/Lettering.js
*/


(function() {
  var __slice = [].slice;

  (function($) {
    var Action, UNIQUE_STR, actionTypeFromEl, log, methods, settings;

    settings = {};
    UNIQUE_STR = "eefec303079ad17405c889e092e105b0";
    log = function() {
      var msg, others;

      msg = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (settings.debug) {
        if (others.length) {
          return typeof console !== "undefined" && console !== null ? console.log(msg, others) : void 0;
        } else {
          return typeof console !== "undefined" && console !== null ? console.log(msg) : void 0;
        }
      }
    };
    actionTypeFromEl = function(el) {
      if (/\bm-break-parsed\b/.test(el.className)) {
        return 'break';
      } else {
        return 'pause';
      }
    };
    Action = (function() {
      function Action(nextElement, prevElement, actionClasses, actionType, timing) {
        this.nextElement = nextElement;
        this.prevElement = prevElement;
        this.actionClasses = actionClasses;
        this.actionType = actionType;
        this.timing = timing;
      }

      Action.prototype.eventType = function() {
        var err;

        try {
          return this.actionClasses.match(/\bm-action-(input|timeout)\b/)[1];
        } catch (_error) {
          err = _error;
          switch (this.actionType) {
            case "pause":
              return settings.actionOnPause;
            case "break":
              return settings.actionOnBreak;
          }
        }
      };

      return Action;

    })();
    methods = {
      init: function(options) {
        settings = {
          debug: false,
          actionOnPause: 'timeout',
          actionOnBreak: 'input',
          pauseMilliseconds: 1000
        };
        settings = $.extend(settings, options);
        return this.each(function() {
          var jqEl;

          log("Initializing Magicio for element with id \"" + this.id + "\"");
          jqEl = $(this);
          methods.parse(jqEl);
          return methods.buildActions(jqEl);
        });
      },
      destroy: function(jqEl) {
        return this.each(function() {
          log("Destroying Magicio for element with id \"" + this.id + "\"");
          return $(this).removeData('magicio');
        });
      },
      buildActions: function(jqEl) {
        var actions, actors;

        actors = jqEl.data('magicio').actors;
        jqEl.removeData('magicio', 'actors');
        actions = $.map(actors, function(el, i) {
          var actionClasses, actionType, err, nextElement, prevActionType, prevElement, timing;

          if (i > 0) {
            prevActionType = (function() {
              try {
                return actionTypeFromEl(actors[i - 1]);
              } catch (_error) {
                err = _error;
                return null;
              }
            })();
            actionType = actionTypeFromEl(el);
            actionClasses = el.className.replace(/m-(pause|break)(-parsed)?/g, '');
            nextElement = el;
            prevElement = (function() {
              if (actionType === 'break') {
                try {
                  return $(el).prev('.m-break-parsed')[0];
                } catch (_error) {
                  err = _error;
                  return null;
                }
              } else {
                if (prevActionType === "pause") {
                  return actors[i - 1];
                }
              }
            })();
            timing = (function() {
              try {
                return parseInt(el.className.match(/\bm-timing-(\d+)\b/)[1], 10);
              } catch (_error) {
                err = _error;
                return settings.pauseMilliseconds;
              }
            })();
            return new Action(nextElement, prevElement, actionClasses, actionType, timing);
          }
        });
        log("Actions: %o", actions);
        return jqEl.data('magicio', {
          actions: actions
        });
      },
      parse: function(jqEl) {
        var actors, breaks;

        jqEl.trigger('beforeparse');
        breaks = jqEl.children('.m-break');
        log("Breaks: " + breaks.length);
        if (breaks.length === 0) {
          breaks = jqEl;
        } else {
          breaks.addClass('m-break-parsed');
        }
        breaks.each(function() {
          var elBreak, fragments, pauses;

          elBreak = $(this);
          pauses = elBreak.children('br.m-pause');
          log("Pauses: " + pauses.length);
          pauses.replaceWith(UNIQUE_STR);
          fragments = elBreak.html().split(UNIQUE_STR);
          if (fragments.length > 0) {
            fragments = $.map(fragments, function(frag, i) {
              var classes;

              classes = pauses[i - 1] ? pauses[i - 1].className.replace(/\bm-pause\b/, '') : '';
              return "<span class='m-pause-parsed " + classes + "'>" + frag + "</span>";
            });
            return elBreak.html(fragments.join(''));
          }
        });
        actors = jqEl.find('.m-break-parsed, span.m-pause-parsed');
        log("Actors: %o", actors);
        jqEl.data('magicio', {
          actors: actors
        });
        return jqEl.trigger($.Event('afterparse', {
          actors: actors
        }));
      },
      run: function() {
        return this.each(function() {
          var actions, elData, ixCurrent, jqEl;

          log("Magicio running on element with data: %o", $(this).data('magicio'));
          jqEl = $(this);
          elData = jqEl.data('magicio');
          actions = elData.actions;
          jqEl.trigger($.Event('beforerun', {
            actions: actions
          }));
          ixCurrent = elData.current_action_index || 0;
          return methods.runAction(jqEl, actions, ixCurrent);
        });
      },
      runAction: function(jqEl, actions, ix) {
        var action, inputFn, ixNext, prevAction;

        action = actions[ix];
        prevAction = actions[ix - 1];
        if (prevAction) {
          jqEl.trigger($.Event("after" + prevAction.actionType, {
            action: prevAction
          }));
        }
        if (!action) {
          log("Ran out of actions.");
          jqEl.trigger($.Event("afterrun", {
            actions: actions
          }));
          return true;
        }
        log("Going to execute action %o", action);
        jqEl.trigger($.Event("before" + action.actionType, {
          action: action
        }));
        log("eventType: " + (action.eventType()));
        log("timing: " + action.timing);
        ixNext = ix + 1;
        switch (action.eventType()) {
          case 'timeout':
            setTimeout(function() {
              return methods.runAction(jqEl, actions, ixNext);
            }, action.timing);
            break;
          case 'input':
            inputFn = function() {
              $(document).off('click', inputFn);
              $(document).off('keypress', inputFn);
              return methods.runAction(jqEl, actions, ixNext);
            };
            $(document).on('click', inputFn);
            $(document).on('keypress', inputFn);
        }
        return jqEl.data('magicio', {
          current_action_index: ixNext
        });
      }
    };
    return $.fn.extend({
      magicio: function(method) {
        if (methods[method]) {
          return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else {
          return methods.init.apply(this, arguments);
        }
      }
    });
  })(jQuery);

}).call(this);
